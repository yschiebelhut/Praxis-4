\chapter{Future Work}
\section{Testing the Bootstrap}
When it comes to testing the implemented solution, it is important to distinguish different categories of tests.
On the one hand there are \emph{unit tests} and on the other there are \emph{integration tests}.

\paragraph{Unit tests} are about testing small components of code for functionality in different scenarios.
Do to so, the test usually isolates the components from the remaining code.
Dependencies on other systems are usually swapped out to create this isolation.
(This process is called \emph{mocking}.)
In general, unit tests should not have side effects and should be completely independent of the rest of the application.
Because of this, unit tests are very fast, simpler in structure and therefore also easier to write.

\paragraph{Integration tests} on the other hand are way more complex than unit tests.
Like their name suggests, they test the integration of a module with other modules.
This is done when a unit test is not sufficient for some functions because of its isolation property.
Integration test do not try to mitigate side effects but consider them from the beginning.
Generally, integration tests are more complex to set up and slower than unit tests.
Also, integration test might often rely on external resources which failures are beyond the control of the developer.
As a result, it is usually desirable to use many unit tests and only few integration tests.

The difficulty with the implementation of the bootstrap at this state is that the interaction with \ac{aws} is deeply tied into the business logic of the bootstrap.
As a result, the bootstrap would require integration testing as a verification, although an integration test should only cover the actual interaction with \ac{aws} and not the bootstrap itself which should rather be checked with basic unit tests.
To cover the business logic of the bootstrap with unit tests, the bootstrap therefore has to be decoupled from the interaction with \ac{aws}.
The \ac{aws} part would then have to be covered with an integration test, although a much smaller one, which could focus solely on the third party service and would not get mixed with the departments own business logic.
To do so, there are different approaches that can be chosen from.

\paragraph{Client Interfaces} A common approach to write unit tests for something like the bootstrap would be to replace the clients of the \ac{aws} \ac{sdk} that communicate with the \ac{aws} backend with mocked clients.
These mocked clients could then fake the interaction with \ac{aws} and deliver reproducible results to test the actual business logic.
In Go, this is generally rather easy to achieve through the use of interfaces.
An interface in Go is just a definition of method headers.
Any type that implements the specified methods, automatically also implements the interface.
For making the actual clients interchangeable with mocked clients, interfaces would have to be specified, that defines all \ac{sdk} methods the clients needs.
Then, new types could be constructed, that implement those methods and return the desired values for mocking.
Now, instead of using the types of the actual \ac{sdk} clients when referring to the clients (in this case the types of the client variables in \autoref{code:aws-struct-1}), the interface would be used.
This enables the tests to replace the clients with the mocked clients without changing the program execution, because the same methods can be called but just on a different object.

This is an easy approach if only a few methods have to be mocked.
The problem in the context of this project is, that especially for the \ac{iam} client, many methods would have to be mocked individually, which is a lot of work and difficult to cover all special cases and possible errors.
That is why this approach is less suitable in this case.

\paragraph{Function Pointers}

% \section{Integration with the \ac{cli}}